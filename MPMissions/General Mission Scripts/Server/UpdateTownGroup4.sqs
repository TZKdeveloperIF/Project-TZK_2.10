; args: [unit]
; unit : group leader at start
; Used for $1000 town as extra inf AA group. Must upgrade Town Group Armor first.
_unit = _this select 0
[_unit] exec "Common\InitTownGroups.sqs"
? !(local LocalServerObject) : exit
_unit disableAI "TARGET"; _unit disableAI "AUTOTARGET"; _unit disableAI "MOVE"
~5

_group = group _unit

_distSpawn = viewDistance + 1500
_cLast = 0

_si = -1
? side _unit == sides select si0 : _si = si0
? side _unit == sides select si1 : _si = si1

timeReinforceTown = 45

#Init
_res = [getPos _unit, [siRes], []] call funcGetClosestTown
_flag = (_res select 0) select tdFlag
_posFlag = getPos _flag
_ti = _res select 2
? _si == -1 : format["ERROR: _si == -1 set in UpdateTownGroup.sqs for %1", (towns select _ti) select tdName] call fDebugLog; exit
_siLast = (_res select 0) select tdSide

;deleteVehicle _unit
_unit setpos [1,1,1]; _unit setdamage 1

? isNull _group : format["ERROR: _group is NULL at init for %1 town group in '%1'", sideNames select _si, (towns select _ti) select tdName] call fDebugLog; exit

; (townGroups select _si) set [count (townGroups select _si), _group]

; player globalchat format["townGroups: %1 - %2", count (townGroups select si0), count (townGroups select si1)]

_timeReinforce = time + timeReinforceTown
_bCheckSupport = true
_support = objNull
_unitsSupport = []; _unitsSupporting = []
_unitsInfantry = []; _unitsVehicle = []

@(((upgMatrix select _si) select upgTownGroupb ) == 2)


#Update
  ~(25 + random 10)
	; check if town taken (won)
	_siTown = (towns Select _ti) select tdSide
	? _siTown == _si && _siLast != _si : _timeReinforce = time + timeReinforceTown
	_siLast = _siTown
	? _siTown == _si && time > _timeReinforce : goto "Reinforce"
	? (count (units _group)) == 0 : goto "Update"
	#ReinforceReady
	{ if (alive _x) then { _x doWatch ([getPos _x, 200, 200] call funcGetRandomPos); if (unitReady _x) then { doStop _x } } } forEach units _group	
	? _siTown != _si : goto "TakeFlag"
	? _bCheckSupport : goto "Support"
	goto "Patrol"

#Patrol
  _group setCombatMode "RED"; _group setBehaviour "COMBAT"; _group setSpeedMode "NORMAL"
  ; CHECK HIBERNATE
	; Cancel Hibernate for test.
	; _hibernate = true
	; { _g = _x; { if ((_x distance _flag) < _distSpawn) then { _hibernate = false } } foreach (units _g) } foreach (groupMatrix select (siEnemy select _si))
	; { _g = _x; { if ((_x distance _flag) < _distSpawn) then { _hibernate = false } } foreach (units _g) } foreach (townGroups select (siEnemy select _si))
	; { _g = _x; { if ((_x distance _flag) < _distSpawn) then { _hibernate = false } } foreach (units _g) } foreach (workerGroups select (siEnemy select _si))
	; { _g = _x; { if ((_x distance _flag) < _distSpawn) then { _hibernate = false } } foreach (units _g) } foreach ( (groupMatrix select siRes) - groupsPatrol )
	; { _g = _x; { if ((_x distance _flag) < _distSpawn) then { _hibernate = false } } foreach (units _g) } foreach groupsPatrol
	; ? _hibernate : goto "Hibernate"
  
	_c = count (units _group)
	? _c < _cLast : [_ti, _si] exec "Server\Info\TownGroupLoss.sqs"
	_cLast = _c
	
	{ if ( ( (random 1) < 0.5 || (_x distance _flag) < 50 ) && (alive _x) && !(_x in (_unitsSupport + _unitsSupporting) ) ) then { _x doMove ([_posFlag, 149, 149] call funcGetRandomPos) } } forEach units _group
	goto "Update"

#TakeFlag
	{ if ((random 1) < 0.5 && !(_x in (_unitsSupport + _unitsSupporting)) ) then { _x doMove ([_posFlag, 5, 5] call funcGetRandomPos) } } forEach units _group
	goto "Update"

#Reinforce
	_timeReinforce = time + timeReinforceTown
	_c = count (units _group); _i = _c; _units = units _group
	#ClearDeadinRein
	_i = _i - 1
	? _i >= 0 && _i < count _units : _u = _units select _i; if (!alive _u && _u == vehicle _u) then {deleteVehicle _u}
	? _i > 0 : goto "ClearDeadinRein"
	_unitsInfantry = []; { if ((vehicle _x) == _x) then { _unitsInfantry = _unitsInfantry + [_x] } } forEach (units _group)
	? count (units _group) < 6 : goto "AddInf"
  goto "ReinforceReady"

#AddInf
  _type = -1
  while "_type == -1" do { _type = (infTownH select _si) call funcGetRandomUnitType }
  _pos = [_posFlag, 149, 149] call funcGetRandomPos
  ? isNull _group : format["ERROR: _group is NULL at AddInf for %1 town group in '%1'", sideNames select _si, (towns select _ti) select tdName] call fDebugLog; exit
  [_type, 0, 0, 0, _pos, random 360, _si, giTown, _group, 0, 0] exec "Common\AddUnit.sqs"
  ;player globalchat format["AddInf: %1 (%2)", (towns select _ti) select tdName, count (units _group)]
  goto "ReinforceReady"


#Hibernate
  [_ti, _si] exec "Server\Info\TownGroupHibernate.sqs"
  _unitsSpawn = ("alive _x" count (units _group)); _tanks = 0; _try = 0
  { _v = vehicle _x; if (_v != _x) then {deleteVehicle _v} } forEach (units _group)
  ~1
  {deleteVehicle _x} forEach (units _group)
  
#CheckSpawn
  ~10
    _hibernate = true
  { _g = _x; { if ((_x distance _flag) < _distSpawn) then { _hibernate = false } } foreach (units _g) } foreach (groupMatrix select (siEnemy select _si))
  { _g = _x; { if ((_x distance _flag) < _distSpawn) then { _hibernate = false } } foreach (units _g) } foreach (townGroups select (siEnemy select _si))
  { _g = _x; { if ((_x distance _flag) < _distSpawn) then { _hibernate = false } } foreach (units _g) } foreach (workerGroups select (siEnemy select _si))
  { _g = _x; { if ((_x distance _flag) < _distSpawn) then { _hibernate = false } } foreach (units _g) } foreach ( (groupMatrix select siRes) - groupsPatrol )
  { _g = _x; { if ((_x distance _flag) < _distSpawn) then { _hibernate = false } } foreach (units _g) } foreach groupsPatrol
  ? !_hibernate : goto "Spawn"
	? time > _timeReinforce && _unitsSpawn < 6 : _timeReinforce = time + timeReinforceTown; _unitsSpawn = _unitsSpawn + 1
  goto "CheckSpawn"
  
#Spawn
  ? isNull _group : format["ERROR: _group is NULL at spawn for %1 town group in '%1'", sideNames select _si, (towns select _ti) select tdName] call fDebugLog; exit
  [_ti, _si] exec "Server\Info\TownGroupSpawn.sqs"
  ? _unitsSpawn == 0 : goto "Update"
  _i = 0
  #SpawnAddInf
  _type = -1
  while "_type == -1" do { _type = (infTown select _si) call funcGetRandomUnitType }
  _pos = [_posFlag, 149, 149] call funcGetRandomPos  
  [_type, 0, 0, 0, _pos, random 360, _si, giTown, _group, 0, 0] exec "Common\AddUnit.sqs"
  ~0.2
  _i = _i + 1
  ? _i < _unitsSpawn : goto "SpawnAddInf"
  goto "Update"
  
    
#Support
  ? !(alive _support) : _res = [getPos _flag, _si, typesSupport select _si, []] call funcGetClosestVehicle; goto "Support_VehicleSet"
  _dist = _support distance _flag
  ? _dist > 500 : _res = [getPos _flag, _si, typesSupport select _si, []] call funcGetClosestVehicle; goto "Support_VehicleSet"
  goto "Support_CheckUnits"
  
  #Support_VehicleSet
  _support = _res select 0
  _dist = _res select 1
  ? _dist > 500 : _unitsSupport = []; _unitsSupporting = []; goto "Patrol"
  
  #Support_CheckUnits
  _i = 0
  _units = units _group
  #Support_CheckUnit
    ? !(alive _support) : _unitsSupport = []; _unitsSupporting = []; goto "Patrol"
    ? !(_i < count _units) : goto "Support_Move"
    _u = _units select _i
	_v = vehicle _u
	_i = _i + 1
	
    ? !(alive _u) : goto "Support_CheckUnit"
	? _u in _unitsSupport && (_u distance _support) < rangeSupport : goto "Support_Perform"
	
	; _heal = [_u, _si, giTown] call funcCheckRepair
	; EH is Unscheduled Environment thus stop using sqf on server.
	_heal = false; _damageRate = 0.2
	if (_u == driver vehicle _u) then {_v = vehicle _u; if (_u == _v) then { if ((damage _u) > _damageRate) then {_heal = true} } else { if ((damage _v) > _damageRate) then {_heal = true}; { if ((damage _x) > _damageRate) then { _heal = true } } foreach (crew _v) }; };
	
	; _rearm = [_u, _si, _gi] call funcCheckRearm
	_rearm = false;
	? _u != driver vehicle _u : goto "RearmCheckEnding"
	_v = vehicle _u;
	? _u != _v : goto "RearmCheckNotSoldier"
	_wpnPrim = primaryWeapon _u; _wpnSec = secondaryWeapon _u;
	? _wpnPrim != "" : if ((_u ammo _wpnPrim) == 0 && (count magazines _u) < 3) then {_rearm = true}
	; The "ammo" command using muzzleName as parameter. Guns with multi-muzzles will meet problems here. Use the count of magazines instead before we have commands returning muzzleName.
	? _wpnSec != "" : _SecondaryWeaponMagazines = ["LAWLauncher","CarlGustavLauncher","AALauncher","RPGLauncher","AT4Launcher","9K32Launcher"] + ["CarlGustavIn4_xj200","AAIn4_xj200","AT4In4_xj200","9k32In4_xj200"]; _magazines = magazines _u; if ( ((_u ammo _wpnSec) + ({_x in _SecondaryWeaponMagazines} count _magazines)) <= 1 ) then { _rearm = true }
	; Be cautious!! It's Case-Sensitive when using STRING array to check whether unit has a specific magazine/weapon. The east infantry AA weapon is "9K32" but not "9k32". TZK defined the "9k32In4_xj200" ammo whose name is lower-case. Aiming to let editor realize this knowledge, the "9k32In4_xj200" is remained and not plan to rewrite as upper case.
	; Do not check if soldier is out of Satchel or Mine. The result of secondaryWeapon is rely on particular weapons thus should be edit if soldiers' weapons redefined.

	goto "RearmCheckEnding"
	#RearmCheckNotSoldier
	_rearmData = _v call funcGetRearmData; _rearmMags = _rearmData select 1;
	? (count _rearmMags) <= 0 : goto "RearmCheckEnding"
	_weapons = weapons _v; {if ((_v ammo _x) == 0) then {_rearm = true}} foreach _weapons;
	? _rearm : goto "RearmCheckEnding"
	_sabots = ["Heat120","M1Sabot_xj200","M12Sabot_xj200","T80Sabot_xj200","T90Sabot_xj200","LeoSabot_xj200","PLASabot_xj200","DKMM_Gun155AP_xj200","Sprut_3VBM17_xj200"];
	_guns   = ["Gun120", "M1Gun_xj200",  "M12Gun_xj200",  "T80Gun_xj200",  "T90Gun_xj200",  "LeoGun_xj200",  "PLAGun_xj200",  "Gun155_xj200",       "Sprut_2A75_xj200"];
	_index = 0; while "!_rearm && _index < count _sabots" do { if ( (_sabots select _index) in _rearmMags ) then { if ("_x == (_sabots select _index)" count (magazines _v) < 1) then {_rearm = true}; if ((_v ammo (_guns select _index)) < ((call grpSetting) select aisAutoRearmSabot)) then {_rearm = true}; }; _index = _index + 1; };
	;Do not check if vehicle is out of a magazine, such as Sabot/Heat to Tank Gun.
	#RearmCheckEnding
	
	
	? (_heal || _rearm) && !(_u in (_unitsSupport + _unitsSupporting)) : _unitsSupport set [count _unitsSupport, _u]; goto "Support_CheckUnit"
	? (_heal || _rearm) && (_u in _unitsSupporting) : _unitsSupporting = _unitsSupporting - [_u, objNull]; _unitsSupport set [count _unitsSupport, _u]; goto "Support_CheckUnit"
	? !_heal && !_rearm : _unitsSupport - [_u, objNull]; _unitsSupporting = _unitsSupporting - [_u, objNull]
	
    goto "Support_CheckUnit"
    
    #Support_Perform
    ; format["UTG: %1 performs support in %2 ", _u, (towns select _ti) select tdName] call fDebugLog
	[_u, _si, giTown, _v, -1, _support] exec "Server\AI_Heal_TownUnit.sqs"
	[_u, _si, giTown, _v, -1, _support] exec "Server\AI_Rearm_TownUnit.sqs"
	_unitsSupport = _unitsSupport - [_u, objNull]; _unitsSupporting set [count _unitsSupporting, _u]
    goto "Support_CheckUnit"
    
  #Support_Move
  _unitsSupport = _unitsSupport - [objNull]
  ; TEST { if (alive _x) then { _posMove = [getPos _support, 5, 5] call funcGetRandomPos; _x doMove _posMove; player globalchat format["UTG: %1 moves to support in %2 ", _x, (towns select _ti) select tdName]; } } forEach _unitsSupport
  { if (alive _x) then { _posMove = [getPos _support, 5, 5] call funcGetRandomPos; _x doMove _posMove } } forEach _unitsSupport
  goto "Patrol"